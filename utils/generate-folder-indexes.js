#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
let matter = null;
try {
  matter = require('gray-matter');
} catch (error) {
  console.warn('gray-matter not available; using basic frontmatter parser.');
}

const DOCS_ROOT = path.join(__dirname, '..', 'docs', 'pages');
const GENERATED_MARKER = '{/* AUTOGENERATED: This file is generated by utils/generate-folder-indexes.js */}';
const LEGACY_MARKER = '<!-- AUTOGENERATED: This file is generated by utils/generate-folder-indexes.js -->';
const FORCE = process.argv.includes('--force');

function toTitleCase(input) {
  if (!input) return '';
  return input
    .replace(/[._-]+/g, ' ')
    .split(' ')
    .filter(Boolean)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

function parseFrontmatter(raw) {
  if (matter) {
    return matter(raw).data || {};
  }

  const match = raw.match(/^---\n([\s\S]*?)\n---/);
  if (!match) {
    return {};
  }

  const lines = match[1].split('\n');
  const data = {};
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;
    const colonIndex = trimmed.indexOf(':');
    if (colonIndex === -1) continue;
    const key = trimmed.slice(0, colonIndex).trim();
    let value = trimmed.slice(colonIndex + 1).trim();
    value = value.replace(/^['"]|['"]$/g, '');
    if (key && value && !(key in data)) {
      data[key] = value;
    }
  }
  return data;
}

function readFrontmatterTitle(filePath) {
  try {
    const raw = fs.readFileSync(filePath, 'utf8');
    const parsed = parseFrontmatter(raw);
    const title = parsed && typeof parsed.title === 'string'
      ? parsed.title.trim()
      : '';
    return title || '';
  } catch (error) {
    console.warn(`Warning: unable to read frontmatter from ${filePath}: ${error.message}`);
    return '';
  }
}

function escapeFrontmatterValue(value) {
  return value.replace(/"/g, '\\"');
}

function toRoutePathFromRelative(relativePath) {
  const normalized = relativePath.replace(/\\/g, '/');
  const withoutExtension = normalized.replace(/\.mdx$/i, '');
  let route = `/${withoutExtension}`;
  route = route.replace(/\/+/g, '/');
  if (route.length > 1 && route.endsWith('/index')) {
    route = route.slice(0, -('/index'.length));
  }
  if (route.length > 1 && route.endsWith('/')) {
    route = route.slice(0, -1);
  }
  return route;
}

function buildPageEntries(dirPath, files) {
  return files.map((file) => {
    const filePath = path.join(dirPath, file.name);
    const route = toRoutePathFromRelative(path.relative(DOCS_ROOT, filePath));
    const fallbackTitle = toTitleCase(file.name.replace(/\.mdx$/i, ''));
    const title = readFrontmatterTitle(filePath) || fallbackTitle;
    return {
      title,
      route,
    };
  }).sort((a, b) => a.title.localeCompare(b.title, undefined, { sensitivity: 'base' }));
}

function buildSubsectionEntries(dirPath, subdirs) {
  return subdirs.map((dirent) => {
    const childPath = path.join(dirPath, dirent.name);
    const indexPath = path.join(childPath, 'index.mdx');
    const route = toRoutePathFromRelative(path.relative(DOCS_ROOT, childPath));
    let title = '';
    if (fs.existsSync(indexPath)) {
      title = readFrontmatterTitle(indexPath);
    }
    if (!title) {
      title = toTitleCase(dirent.name);
    }
    return {
      title,
      route,
      hasIndex: fs.existsSync(indexPath),
    };
  }).filter((entry) => entry.hasIndex)
    .sort((a, b) => a.title.localeCompare(b.title, undefined, { sensitivity: 'base' }));
}

function hasGeneratedMarker(content) {
  if (!content) return false;
  return content.includes(GENERATED_MARKER) || content.includes(LEGACY_MARKER);
}

function writeIndex(dirPath, pageEntries, subsectionEntries) {
  const indexPath = path.join(dirPath, 'index.mdx');
  const relativeIndex = path.relative(DOCS_ROOT, indexPath) || 'index.mdx';
  const existingContent = fs.existsSync(indexPath)
    ? fs.readFileSync(indexPath, 'utf8')
    : null;
  const isGenerated = hasGeneratedMarker(existingContent);

  if (existingContent && !isGenerated && !FORCE) {
    console.log(`Skipping ${relativeIndex} (manual index detected)`);
    return;
  }

  if (pageEntries.length === 0 && subsectionEntries.length === 0) {
    if (isGenerated) {
      fs.unlinkSync(indexPath);
      console.log(`Removed empty generated index ${relativeIndex}`);
    }
    return;
  }

  const folderTitle = (() => {
    if (dirPath === DOCS_ROOT) {
      return 'Documentation';
    }
    const segment = path.basename(dirPath);
    return toTitleCase(segment);
  })();

  const lines = [];
  lines.push('---');
  lines.push(`title: "${escapeFrontmatterValue(folderTitle)}"`);
  lines.push('---');
  lines.push('');
  lines.push(GENERATED_MARKER);
  lines.push('');
  lines.push(`# ${folderTitle}`);

  if (pageEntries.length > 0) {
    lines.push('');
    lines.push('## Pages');
    lines.push('');
    pageEntries.forEach(({ title, route }) => {
      lines.push(`- [${title}](${route})`);
    });
  }

  const pageRouteSet = new Set(pageEntries.map(({ route }) => route.toLowerCase()));
  const uniqueSubsections = subsectionEntries.filter(({ route }) => !pageRouteSet.has(route.toLowerCase()));

  if (uniqueSubsections.length > 0) {
    lines.push('');
    lines.push('## Subsections');
    lines.push('');
    uniqueSubsections.forEach(({ title, route }) => {
      lines.push(`- [${title}](${route})`);
    });
  }

  lines.push('');

  const nextContent = lines.join('\n');

  if (existingContent === nextContent) {
    console.log(`Unchanged ${relativeIndex}`);
    return;
  }

  fs.writeFileSync(indexPath, `${nextContent}`);
  console.log(`${existingContent ? 'Updated' : 'Created'} ${relativeIndex}`);
}

function shouldIgnoreDirectory(name) {
  return name.startsWith('.') || name === 'node_modules';
}

function generateAll(dirPath) {
  const entries = fs.readdirSync(dirPath, { withFileTypes: true });

  const subdirs = entries.filter((entry) => entry.isDirectory() && !shouldIgnoreDirectory(entry.name));
  subdirs.forEach((dirent) => generateAll(path.join(dirPath, dirent.name)));

  const mdxFiles = entries.filter((entry) => entry.isFile()
    && entry.name.toLowerCase().endsWith('.mdx')
    && entry.name.toLowerCase() !== 'index.mdx');

  const pageEntries = buildPageEntries(dirPath, mdxFiles);
  const subsectionEntries = buildSubsectionEntries(dirPath, subdirs);

  writeIndex(dirPath, pageEntries, subsectionEntries);
}

function main() {
  if (!fs.existsSync(DOCS_ROOT)) {
    console.error(`Docs directory not found at ${DOCS_ROOT}`);
    process.exit(1);
  }

  generateAll(DOCS_ROOT);
}

if (require.main === module) {
  main();
}

module.exports = {
  main,
  generateAll,
  writeIndex,
};
