---
title: "Safe Multisig: Step-by-Step Verification"
tags:
  - Engineer/Developer
  - Security Specialist
  - Operations & Strategy
contributors:
  - role: wrote
    users: [isaac, geoffrey, louis, pablo, dickson]
  - role: reviewed
    users: [pinalikefruit, engn33r]

---

import { TagList, AttributionList, TagProvider, TagFilter, ContributeFooter } from '../../../components'

<TagProvider>
<TagFilter />

# Safe Multisig: Step-by-Step Verification

<TagList tags={frontmatter.tags} />
<AttributionList contributors={frontmatter.contributors} />

Hash verification protects against UI compromise attacks where malicious transactions are injected into the signing flow. The goal is to ensure that what you see in the UI matches what your hardware wallet actually signs.

## General Signing Guidelines

- Use hardware wallet and back up the seed phrase
- Use a separate browser or browser profile for signing
- Secure signing environment (dedicated or hardened device)
- Communicate transaction status and re-verify before execution

## Key Definitions (EVM)

- Domain Hash (EIP-712 domain separator)
- Message Hash (raw hash of transaction params)
- SafeTxHash (combined domain + message hash)

## Recommended Tools

- Safe Tx Hashes Util (CLI)
- OpenZeppelin Safe Utils (Web UI)
- Lido Safe TX Hashes Calculation, Cyfrin Safe Hashes RS

## 1) Transaction Preparation

- Use delegated proposer (recommended)
- Ensure the transaction is proposed in the Safe API
- Record Safe address, network, nonce

## 2) Simulation Testing

- Run Tenderly simulation from Safe UI; verify expected events and transfers
- If using a timelock, expect a staged transaction event rather than execution

![Tenderly simulation setup](https://frameworks-static.s3.us-east-2.amazonaws.com/images/multisig-for-protocols/tenderly-simulation-setup.png)

Manual simulation (when needed):
1. Paste the contract address in the contract field
2. Paste the calldata from the Safe UI or from the hash verification tool
3. Specify the Safe address as the From address

Note: For complex batch transactions that include a delegateCall to multisend, manual simulations may not be feasible.

## 3) Hash & Calldata Verification

- CLI: `./safe_hashes.sh --network [NETWORK] --address [SAFE_ADDRESS] --nonce [NONCE]`
- Interactive mode available (enter details manually)
- Web UI alternative via OpenZeppelin Safe Utils
- Always use checksummed addresses

### Using web UI (OpenZeppelin Safe Utils)
1. Navigate to OpenZeppelin Safe Utils
2. Enter Safe address (checksummed)
3. Select network and enter nonce
4. Review generated hashes and decoded calldata

### Checksummed address examples
- ✅ Correct: `0xA79C6968E3c75aE4eF388370d1f142720D498fEC`
- ❌ Incorrect: `0xa79c6968e3c75ae4ef388370d1f142720d498fec`

- Interactive mode note: In interactive mode the CLI does not decode calldata; be sure to perform the calldata verification in step 5.

## 4) Hash Comparison

- Message Hash on tools must match hardware wallet display
- Domain Hash ensures correct Safe
- SafeTxHash for nested Safe approvals

## 5) Calldata Review

- Decode calldata (e.g., SwissKnife)
- Verify functions, recipients, amounts; watch for risky operations

### Tool diversity recommendation

Signers should not all use identical tools. Cross-verify results between multiple tools (CLI and web) for critical operations.

## Special Cases: Nested Safes

- Use `--nested-safe-address` and `--nested-safe-nonce` to verify approveHash flows

---

## Related Documents

- [Hardware Wallet Setup](/multisig-for-protocols/hardware-wallet-setup)
- [Backup Signing & Infrastructure](/multisig-for-protocols/backup-signing-and-infrastructure)
- [Emergency Procedures](/multisig-for-protocols/emergency-procedures)
- [Tools & Resources](/wallet-security/tools-&-resources)

</TagProvider>
<ContributeFooter />

