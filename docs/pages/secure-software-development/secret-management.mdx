---
title: "Secret Management"
tags:
  - Engineer/Developer
  - Security Specialist
contributors:
  - role: wrote
    users: [robert]
---

import { TagList, AttributionList, TagProvider, TagFilter, ContributeFooter, MermaidRenderer } from '../../../components'

# Secret Management

<TagProvider>
<TagFilter />

<TagList tags={frontmatter.tags} />
<AttributionList contributors={frontmatter.contributors} />

Secret management involves securely handling sensitive information such as API keys, passwords, private keys, and tokens used by applications. Proper secret management aims to prevent unauthorized access, minimize the impact of potential leaks, and ensure easy rotation and revocation of secrets.

## Why Secret Management Matters

Compromised secrets can lead to:

- Unauthorized access to systems and data
- Data breaches and leaks
- IP theft
- Service disruptions
- Financial losses due to fraud or remediation costs

Poorly managed secrets are a common attack vector and increase the risk of security incidents.

## Secret Lifecycle

Secrets go through distinct lifecycle stages that must be properly managed to maintain security.


<MermaidRenderer id="mermaid-diagram" code={`
flowchart TD
    a[Create] --> b[Store]
    b --> c[Use]
    b --> d[Rotate]
    d --> e[Retire]
    e --> a
`} />


### Creation

Secrets should be created using strong cryptographic methods and automated tools to avoid human error. Each secret should follow the principal of least privilege, with its purpose and owner clearly documented.

### Storage

Secrets must be stored securely using encryption both at rest and in transit. Avoid hardcoding secrets. See the Scenario-Based Recommendations section below for specific storage solutions based on your environment.

### Rotation

Secrets should be rotated regularly to minimize the risk of compromise. Automated rotation mechanisms are more complex to setup, but are more reliable and can ensure timely updates. When rotating secrets, ensure:
- All dependent systems are updated before deprecating old secrets
- Use dynamic secrets where possible to reduce manual rotation

A baseline schedule (adjust to your risk level) could be:

| Secret Type | Rotation Frequency |
| --- | --- |
| Low-impact development secrets | 180-360 days |
| Standard production credentials | 90-180 days |
| High-risk secrets (e.g. admin keys) | 30-90 days |
| Signing or HSM-bound keys | Only if suspected compromise |

### Expiration

Secrets should have set expiration dates specified at creation. This ensures that forgotten or unused secrets do not remain valid indefinitely. Expiration dates can be integrated with rotation policies to enforce regular updates. Expiration policies should:
- Keep at least one previous version for rollback
- Delete expired secrets within 7-30 days of rotation

#### Emergency Procedures

In the event of a suspected secret compromise, have a clear procedure in place to quickly revoke and rotate affected secrets. This should involve:
1. Identify the compromised secrets
2. Expire or revoke the secrets immediately
3. Rotate to new secrets and update all dependent systems
4. Audit access logs to determine the scope of the compromise
5. Communicate incident details with relevant stakeholders
6. Review and improve security practices to prevent future incidents

For more detailed emergency procedures or creating a proper incident response plan, review frameworks like those from NIST, CISA, or CyberSecure Canada depending on your region.

### Monitoring & Auditing

Auditing secret access and modification is crucial for detecting unauthorized use and ensuring compliance. Effective auditing practices include:
- Log all secret access attempts (successful and failed)
  - Store detailed logs for at least 90 days and summarized logs for 12-24 months
- Track who created, modified, or deleted secrets
- Monitor for unusual access patterns
- Review access logs monthly for security incidents
- Create alerts for suspicious log patterns.

Often logs are integrated into dedicated secret management solutions, providing holistic visibility.

#### Secret Scanning

In addition to monitoring access, proactively scan repositories and environments for accidentally committed secrets. Using tools like git-secrets or TruffleHog can help identify exposed secrets before they are exploited.

#### Secret Sprawl

A common metric used to evaluate secret management effectiveness is "[secret sprawl](https://www.hashicorp.com/en/resources/what-is-secret-sprawl-why-is-it-harmful)". Secret sprawl refers to a scattered distribution of secrets across various locations. It can be roughly measured as the number of unique locations where secrets are stored. Reducing secret sprawl by centralizing secret management improves security, simplify rotation, and enhance monitoring.

## Decision Framework

| Factor | Considerations |
| --- | --- |
| Secret Sensitivity | Higher sensitivity requires stronger protection |
| Team Size | Larger teams need robust sharing, access control, auditing |
| Environment Complexity | Multiple environments increase cross-contamination risk |

### Quick Decision Chart

| Scenario | Risk Level | Team Size | Recommendation |
| --- | --- | --- | --- |
| Local development only | Low | Solo | `.env` (gitignored) |
| Shared development | Low-Medium | 2-10 | `git-crypt` or `dotenvx` |
| Multiple environments | Medium | Any | Environment-specific files with `git-crypt`/`dotenvx` |
| Production secrets | High | Any | Dedicated secret manager (Vault or cloud provider) |
| Complex access control | High | Large | Cloud secret manager or Vault |
| Cryptographic operations | Critical | Any | HSM or secure enclave |


## Scenario-Based Recommendations

(See Tools & Solutions section below for detailed descriptions of referenced tools)

### Development Environment

Development environments should never use production secrets. In development the risk of accidental exposure is much higher since secrets may be shared among multiple developers, stored in environment variables, or even committed in plaintext to version control. Using mock secrets ensures that when they are exposed, the impact is minimal.

- **Solo developers:** Use gitignored `.env` files for simplicity
- **Small teams:** Use **git-crypt** or **dotenvx** for encrypted, version-controlled secrets
- **Larger teams:** Use **HashiCorp Vault** or cloud secret managers for centralized control and auditing
- **Multiple environments:** Maintain separate secret files (`.env.dev`, `.env.staging`) with appropriate encryption

Mock or synthetic data in development reduces exposure risk significantly.

### CI/CD Pipeline

Like with development, you should avoid using production secrets in CI/CD environments. Prefer mock or staging environments with separate secrets.

- Use platform-native secret storage (*GitHub Actions Secrets*, *GitLab CI/CD Variables*)
- For consistency with production, integrate with the same secret manager used in production (*Vault*, cloud providers)
- Never commit secrets to repositories, even temporarily
- Rotate CI/CD secrets regularly, especially after team member departures

### Production Environments

#### Client-Side Applications

Client-side secret management is inherently challenging since secrets must be stored on a user's device and are therefore always vulnerable to extraction. User credentials can be issued by the backend and stored securely using platform-specific solutions. In general aim to store sensitive user data on-device and securely, and store sensitive production secrets in the backend.

- Issue tokens from backend, never embed secrets in apps
- Store using platform-specific secure storage (*iOS Keychain*, *Android Keystore*)
- Use short-lived tokens with automatic rotation (OAuth2 with refresh tokens)
- Consider authentication services: *Firebase Authentication*, *Supabase*, *Authelia*

#### Self-Hosted Applications

For self-hosted applications, you will typically need to manage secrets more directly. In basic setups, secrets might be stored in environment variables or configuration files. This approach is straightforward but leaves secrets in plaintext on the host system and can be inconvenient to rotate or manage across multiple instances. Many orchestration tools provide built-in secret management features which securely store and distribute secrets to containers or services. These can be a good middle ground for many applications.

- **Basic setups:** Environment variables or configuration files (straightforward but secrets in plaintext)
- **Orchestrated deployments:** Use *Docker Swarm secrets* or *Kubernetes secrets* for secure distribution
- **Production systems:** Use *HashiCorp Vault* for automatic rotation, access control, and auditing
- **OS-level storage:** *Linux Keyring* for server-based secret storage

#### Cloud Environments

Cloud providers generally offer built-in secret management solutions designed to integrate with their services. While it's often possible to use third-party secret management tools, leveraging their native solutions simplifies procedures and reduces the risk of misconfiguration. For particularly sensitive operations, some cloud providers also offer secure enclaves or hardware security modules (HSMs). These trusted execution environments ([TEEs](https://learn.microsoft.com/en-us/azure/confidential-computing/trusted-execution-environment#what-is-a-tee)) ensure that secrets are never exposed in plaintext outside the enclave.

- **Prefer native solutions:** *AWS Secrets Manager*, *GCP Secret Manager*, *Azure Key Vault* integrate seamlessly with cloud services
- **Third-party tools:** *HashiCorp Vault* works across clouds but adds complexity
- **High-security needs:** Use *AWS Nitro Enclaves* or specialized services like *Turnkey* for TEE guarantees
- **HSMs:** Available from cloud providers for cryptographic operations requiring hardware security


## Example Profiles

### Solo Developer

Individual developer working on personal or low-risk projects. Aims for simplicity while maintaining basic security.

- **Development:** `.env` files (gitignored)
- **Version Control:** Add `.env` to `.gitignore`, commit `.env.example` with dummy values
- **CI/CD:** GitHub Actions Secrets or GitLab CI/CD Variables
- **Production:** Cloud provider secret manager (AWS/GCP/Azure) if using cloud; environment variables if self-hosting

### Small Team (2-10 developers)

Startup or small team collaborating on a project. Aims to balance rapid collaboration 
and development with security needs, allowing easy and secure secret sharing without 
additional infrastructure.

- **Development:** `git-crypt` or `dotenvx` for encrypted, shared secrets in Git
- **Version Control:** Encrypted `.env` files per environment (`.env.dev`, `.env.staging`)
- **CI/CD:** Load shared secrets from `git-crypt`/`dotenvx` with CI/CD-specific access controls
- **Self-Hosted:** Linux Keyring or Docker/Kubernetes secrets
- **Cloud Production:** Cloud provider secret manager with IAM-based access control

### Medium Team (10-100 developers)

Growing company with multiple services and environments. Aims to implement auditable,
scalable secret management with automated rotation and fine-grained access control.

- **Development:** HashiCorp Vault (self-hosted or Cloud) with per-developer tokens
- **Version Control:** No secrets in Git; reference Vault paths in config files
- **CI/CD:** Vault integration with dynamic secret generation for pipelines
- **Production:** Vault for self-hosted; cloud secret managers with Vault sync for hybrid setups

### Enterprise

Large organization with compliance requirements and sensitive data. Similar to 
medium team but with added focus on compliance, auditing, and very sensitive data.

- **Development:** HashiCorp Vault with SSO integration (LDAP/SAML)
- **Version Control:** No secrets in Git; infrastructure-as-code references Vault paths
- **CI/CD:** Vault with short-lived dynamic credentials per pipeline run
- **Production:**
  - Cloud secrets: Native cloud secret managers with compliance logging
  - Self-hosted: Vault with HSM backend for signing keys
  - Client apps: Platform secure storage + backend authentication services
  - Cryptographic operations: Hardware HSMs or secure enclaves
  - Developer Authentication: SSO or hardware tokens (YubiKey)

## Tools & Solutions

### Local Development Tools

| Tool | Description | Best For |
| --- | --- | --- |
| `.env` files | Plain text files (gitignored) storing key-value pairs | Solo developers, low-risk secrets, local development |
| [git-crypt](https://github.com/AGWA/git-crypt) | Transparent encryption for files in Git repositories | Small teams, version-controlled secrets, simple sharing across members and environments |
| [dotenvx](https://dotenvx.com/) | Enhanced .env with encryption and environment management | Small teams, version-controlled secrets, simple sharing across members and environments |

### CI/CD Platform Secrets

| Tool | Description | Best For |
| --- | --- | --- |
| [GitHub Actions Secrets](https://docs.github.com/en/actions/how-to-guides/write-workflows/choose-what-workflows-do/use-secrets) | Encrypted environment variables for workflows | GitHub-based CI/CD pipelines |
| [GitLab CI/CD Variables](https://docs.gitlab.com/charts/installation/secrets/) | Protected and masked variables | GitLab-based CI/CD pipelines |

### Orchestration Tools

| Tool | Description | Best For |
| --- | --- | --- |
| [Docker Swarm Secrets](https://docs.docker.com/engine/swarm/secrets/) | Encrypted secret distribution to containers | Docker Swarm orchestrated applications |
| [Kubernetes Secrets](https://kubernetes.io/docs/concepts/configuration/secret/) | Secret objects mounted as files or environment variables (unencrypted by default) | Kubernetes orchestrated applications |

### Dedicated Secret Managers

| Tool | Description | Best For |
| --- | --- | --- |
| [HashiCorp Vault](https://developer.hashicorp.com/vault) | Self-hosted/cloud secret manager with automatic rotation, fine-grained access control, auditing, dynamic secrets | Medium to large teams, multi-cloud, complex access control needs |
| [AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html) | AWS-native secret manager with automatic rotation and RDS integration | AWS-based applications requiring native integration |
| [GCP Secret Manager](https://docs.cloud.google.com/secret-manager/docs) | GCP-native secret manager with IAM integration, versioning, regional replication | GCP-based applications requiring native integration |

### Authentication

| Tool | Description | Best For |
| --- | --- | --- |
| [Firebase Authentication](https://firebase.google.com/docs/auth) | Cloud authentication with OAuth2, token refresh, multi-provider support | Mobile and web apps needing quick auth setup |
| [Supabase Auth](https://supabase.com/docs/guides/auth) | Cloud/self-hosted authentication with row-level security and JWT tokens | Apps using Supabase backend or needing self-hosted auth |
| [Authelia](https://www.authelia.com/) | Self-hosted authentication with 2FA, SSO, LDAP integration | Self-hosted environments |
| [Yubikey](https://www.yubico.com/) | Hardware authentication token for 2FA and secure access | Highly secure authentication needs, higher cost |

### Hardware Security

| Tool | Description | Best For |
| --- | --- | --- |
| Hardware Security Modules (HSMs) | Physical devices for cryptographic operations | Extremely sensitive keys, highly secure when self-hosted, complex to maintain |
| [AWS Nitro Enclaves](https://aws.amazon.com/ec2/nitro/nitro-enclaves/) | Trusted execution environment for isolated compute | AWS-based sensitive data processing with isolation guarantees |
| [Turnkey](https://www.turnkey.com/) | Managed TEE service for cryptographic operations | Signing keys, crypto wallets, key management as a service |

### Client-Side Secure Storage

| Tool | Description | Best For |
| --- | --- | --- |
| [iOS Keychain](https://developer.apple.com/documentation/security/keychain-services) | Secure credential storage with OS-level encryption | iOS app user credentials and sensitive data |
| [Android Keystore](https://developer.android.com/privacy-and-security/keystore) | Hardware-backed key storage when available | Android app cryptographic keys and credentials |
| [Linux Keyring](https://www.kernel.org/doc/html/v5.0/security/keys/core.html) | Kernel-level key management | Linux credential storage |

### Secret Scanning

| Tool | Description | Best For |
| --- | --- | --- |
| [git-secrets](https://github.com/awslabs/git-secrets) | Pre-commit hook that prevents committing secrets to Git | Local development, preventing accidental commits |
| [TruffleHog](https://github.com/trufflesecurity/trufflehog) | Scans Git history for secrets using entropy detection and regex patterns | Auditing existing repositories, CI/CD scanning |
| [GitHub Secret Scanning](https://docs.github.com/en/code-security/secret-scanning) | Built-in scanning that detects secrets in repositories | GitHub users, automatic protection |

### Incident Response Frameworks

- [NIST Computer Security Incident Handling Guide](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-61r2.pdf)
- [CISA Cybersecurity Incident & Vulnerability Response Playbooks](https://www.cisa.gov/sites/default/files/2024-08/Federal_Government_Cybersecurity_Incident_and_Vulnerability_Response_Playbooks_508C.pdf)
- [CyberSecure Canada: Develop an Incident Response Plan](https://ised-isde.canada.ca/site/cybersecure-canada/en/certification-tools/develop-incident-response-plan-fillable-template-and-example)

<ContributeFooter />
</TagProvider>
